Project Architecture: A Resilient, Hybrid RAG System
Our final system is an advanced, multi-stage RAG (Retrieval-Augmented Generation) pipeline designed for both high performance and accuracy. It intelligently adapts its strategy based on the query's difficulty.

üß† Core Logic: The "Smart" Query Pipeline
This is the heart of the application. Instead of a simple one-size-fits-all approach, it uses a two-step fallback mechanism.

Step 1: Fast RAG (The Fast Lane)

The system first attempts to answer every question using an efficient RAG process.

Retrieval: It uses a local, high-quality SentenceTransformer model (BAAI/bge-base-en-v1.5) to create a vector for the question. This vector is used to search the local FAISS index.

Dynamic k: The number of context chunks retrieved (k) is dynamic‚Äîsimpler questions get fewer, more focused chunks (k=5), while complex questions get more context (k=10).

Generation: The retrieved context is passed to a fast LLM, gemini-2.0-flash-lite, to generate a quick initial answer.

Step 2: Intelligent Fallback (The Power Lane)

The system then acts as its own quality controller. It automatically triggers a fallback to a more powerful method if:

The initial retrieval quality from FAISS is poor (the similarity score is below our configured RETRIEVAL_SCORE_THRESHOLD).

The answer generated by the fast RAG step seems weak (e.g., it's too short or contains phrases like "not available").

Fallback Method: If triggered, the system sends the entire document's text to a more powerful LLM, gemini-1.5-pro-latest, for a deep, full-context analysis.

‚ö°Ô∏è Performance & Caching
The architecture is designed for speed and efficiency, especially for repeated requests.

Persistent Caching: For any new document, the system performs a one-time "ingestion" process. It downloads the PDF, chunks it, and creates two files on the server's disk:

A FAISS vector index (.faiss/.pkl files).

A full-text cache (.txt file).
This Persistent Local FAISS setup means that for any subsequent requests for the same document, the system loads the index directly from the disk in under a second, completely skipping the slow download and embedding steps.

Concurrent Processing: When a request contains multiple questions, the system uses asyncio.gather to process them all in parallel, dramatically reducing the total response time.

üõ°Ô∏è Robustness & Reliability
The system is built with production-grade features to ensure it runs smoothly.

Rate Limiting: An asyncio.Semaphore is used to limit the number of concurrent calls to the external Gemini API, preventing us from hitting free-tier rate limits.

Resilient Downloads: The httpx client automatically retries failed PDF downloads with an exponential backoff strategy.

External Configuration: All key performance parameters (concurrency, cache age, thresholds) are managed via the .env file, allowing for easy tuning without changing the code.

Structured Logging: The system maintains a detailed hackrx.log file, which is essential for monitoring performance and debugging issues on the deployment server.